// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package oapi

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AccessTokenResponseTokenType.
const (
	Bearer AccessTokenResponseTokenType = "Bearer"
)

// Defines values for Role.
const (
	Admin  Role = "admin"
	Member Role = "member"
	None   Role = "none"
)

// AccessTokenResponse defines model for AccessTokenResponse.
type AccessTokenResponse struct {
	// AccessToken JWT access token (store in memory; avoid localStorage if possible)
	AccessToken string                       `json:"accessToken"`
	ExpiresIn   int                          `json:"expiresIn"`
	TokenType   AccessTokenResponseTokenType `json:"tokenType"`
}

// AccessTokenResponseTokenType defines model for AccessTokenResponse.TokenType.
type AccessTokenResponseTokenType string

// Account defines model for Account.
type Account struct {
	Email    Email    `json:"email"`
	Fullname Fullname `json:"fullname"`

	// Password 8-72 characters, including at least one uppercase, one lowercase, one digit, and one special character; no whitespace.
	Password *Password `json:"password,omitempty"`

	// PhoneNumber Abide by the E.164 standard
	PhoneNumber *PhoneNumber `json:"phoneNumber,omitempty"`
	Role        Role         `json:"role"`
	Username    Username     `json:"username"`
}

// Email defines model for Email.
type Email = openapi_types.Email

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error struct {
		Code    string                  `json:"code"`
		Details *map[string]interface{} `json:"details,omitempty"`
		Message string                  `json:"message"`
	} `json:"error"`
}

// Fullname defines model for Fullname.
type Fullname = string

// Password 8-72 characters, including at least one uppercase, one lowercase, one digit, and one special character; no whitespace.
type Password = string

// PhoneNumber Abide by the E.164 standard
type PhoneNumber struct {
	CountryCode *string `json:"countryCode,omitempty"`
	Number      *string `json:"number,omitempty"`
}

// RefreshResponse defines model for RefreshResponse.
type RefreshResponse struct {
	AccessToken AccessTokenResponse `json:"accessToken"`
	Username    Username            `json:"username"`
}

// Role defines model for Role.
type Role string

// SigninRequest defines model for SigninRequest.
type SigninRequest struct {
	// Password 8-72 characters, including at least one uppercase, one lowercase, one digit, and one special character; no whitespace.
	Password *Password `json:"password,omitempty"`

	// RememberMe If true, server may issue longer refresh token lifetime.
	RememberMe *bool    `json:"rememberMe,omitempty"`
	Username   Username `json:"username"`
}

// SigninResponse defines model for SigninResponse.
type SigninResponse struct {
	AccessToken AccessTokenResponse `json:"accessToken"`
	Username    Username            `json:"username"`
}

// SignoutRequest defines model for SignoutRequest.
type SignoutRequest struct {
	// IsRevoked Revoked sessions for this user
	IsRevoked bool `json:"isRevoked"`
}

// SignupRequest defines model for SignupRequest.
type SignupRequest struct {
	Account Account `json:"account"`
}

// SignupResponse defines model for SignupResponse.
type SignupResponse struct {
	AccessToken AccessTokenResponse `json:"accessToken"`
	Username    Username            `json:"username"`
}

// Username defines model for Username.
type Username = string

// UsersMeResponse defines model for UsersMeResponse.
type UsersMeResponse struct {
	Account Account `json:"account"`
}

// N400BadRequest defines model for 400_BadRequest.
type N400BadRequest = ErrorResponse

// N401Unauthorized defines model for 401_Unauthorized.
type N401Unauthorized = ErrorResponse

// N403Forbidden defines model for 403_Forbidden.
type N403Forbidden = ErrorResponse

// N429TooManyRequests defines model for 429_TooManyRequests.
type N429TooManyRequests = ErrorResponse

// N500InternalServerError defines model for 500_InternalServerError.
type N500InternalServerError = ErrorResponse

// RefreshTokenParams defines parameters for RefreshToken.
type RefreshTokenParams struct {
	// XRefreshToken refresh token header
	XRefreshToken string `json:"X-Refresh-Token"`
}

// SignOutParams defines parameters for SignOut.
type SignOutParams struct {
	// XRefreshToken Refresh token to revoke (if not using cookie/body).
	XRefreshToken string `json:"X-Refresh-Token"`
}

// SingInJSONRequestBody defines body for SingIn for application/json ContentType.
type SingInJSONRequestBody = SigninRequest

// SignOutJSONRequestBody defines body for SignOut for application/json ContentType.
type SignOutJSONRequestBody = SignoutRequest

// SignUpJSONRequestBody defines body for SignUp for application/json ContentType.
type SignUpJSONRequestBody = SignupRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Refresh access token using refresh token
	// (POST /auth/refresh)
	RefreshToken(c *gin.Context, params RefreshTokenParams)
	// Sign in
	// (POST /auth/signin)
	SingIn(c *gin.Context)
	// Sign out and revoke refresh token
	// (POST /auth/signout)
	SignOut(c *gin.Context, params SignOutParams)
	// Sign up a new account
	// (POST /auth/signup)
	SignUp(c *gin.Context)
	// Get current user information
	// (GET /users/me)
	GetMe(c *gin.Context)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandler       func(*gin.Context, error, int)
}

type MiddlewareFunc func(c *gin.Context)

// RefreshToken operation middleware
func (siw *ServerInterfaceWrapper) RefreshToken(c *gin.Context) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params RefreshTokenParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Refresh-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Refresh-Token")]; found {
		var XRefreshToken string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Refresh-Token, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Refresh-Token", valueList[0], &XRefreshToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Refresh-Token: %w", err), http.StatusBadRequest)
			return
		}

		params.XRefreshToken = XRefreshToken

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Refresh-Token is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.RefreshToken(c, params)
}

// SingIn operation middleware
func (siw *ServerInterfaceWrapper) SingIn(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SingIn(c)
}

// SignOut operation middleware
func (siw *ServerInterfaceWrapper) SignOut(c *gin.Context) {

	var err error

	c.Set(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SignOutParams

	headers := c.Request.Header

	// ------------- Required header parameter "X-Refresh-Token" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-Refresh-Token")]; found {
		var XRefreshToken string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandler(c, fmt.Errorf("Expected one value for X-Refresh-Token, got %d", n), http.StatusBadRequest)
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-Refresh-Token", valueList[0], &XRefreshToken, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandler(c, fmt.Errorf("Invalid format for parameter X-Refresh-Token: %w", err), http.StatusBadRequest)
			return
		}

		params.XRefreshToken = XRefreshToken

	} else {
		siw.ErrorHandler(c, fmt.Errorf("Header parameter X-Refresh-Token is required, but not found"), http.StatusBadRequest)
		return
	}

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SignOut(c, params)
}

// SignUp operation middleware
func (siw *ServerInterfaceWrapper) SignUp(c *gin.Context) {

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.SignUp(c)
}

// GetMe operation middleware
func (siw *ServerInterfaceWrapper) GetMe(c *gin.Context) {

	c.Set(BearerAuthScopes, []string{})

	for _, middleware := range siw.HandlerMiddlewares {
		middleware(c)
		if c.IsAborted() {
			return
		}
	}

	siw.Handler.GetMe(c)
}

// GinServerOptions provides options for the Gin server.
type GinServerOptions struct {
	BaseURL      string
	Middlewares  []MiddlewareFunc
	ErrorHandler func(*gin.Context, error, int)
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router gin.IRouter, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, GinServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router gin.IRouter, si ServerInterface, options GinServerOptions) {
	errorHandler := options.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(c *gin.Context, err error, statusCode int) {
			c.JSON(statusCode, gin.H{"msg": err.Error()})
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandler:       errorHandler,
	}

	router.POST(options.BaseURL+"/auth/refresh", wrapper.RefreshToken)
	router.POST(options.BaseURL+"/auth/signin", wrapper.SingIn)
	router.POST(options.BaseURL+"/auth/signout", wrapper.SignOut)
	router.POST(options.BaseURL+"/auth/signup", wrapper.SignUp)
	router.GET(options.BaseURL+"/users/me", wrapper.GetMe)
}
